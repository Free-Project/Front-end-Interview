## 浏览器渲染页面过程


## 一、概念解释

- **DOM Tree**：浏览器将HTML解析成树形的数据结构。  
- **CSS Rule Tree**：浏览器将CSS解析在树形的数据结构。  
- **Render Tree**：DOM和CSSOM(CSS Object Model:CSS对象模型)合并后生成Render Tree。  
- **layout**：有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS的定义以及他们的从属关系，从而去计算出每个节点的屏幕中的位置。  
- **painting**：按照算出来的规则，通过显卡，把内容画到屏幕上。  
- **reflow(回流)**：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，称此为回退的过程，叫reflow.reflow会从`<html>`这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置。feflow几乎是无法避免的。例如：树状目录的折叠，展开，实质上是元素的显示与隐藏等，都将引起浏览器的reflow，鼠标划过，点击，只要这些行为引起了页面上的某些元素的占位面积，定位方式，边距等属性的变化，都会引起它的内部，周围甚至整个页面的重新渲染。  
- **repaint(重绘)**：改变某个元素的背景色，文字颜色，边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。 

注意点：
1. display:none的节点不会被加入Render Tree,而visibility:hidden则会，所以如果某个节点最开始是不显示的，设为display:none是最好的
2. display:none会触发reflow，而visibility:hidden只会触发repaint,因为位置没有发生变化.
3. 有些情况下，比如修改了元素的样式，浏览器不会立刻reflow和repaint一次，而是会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow,但是有些情况，如resize窗口，改变了页面默认的字体等，对于这些操作，浏览器会马上进行reflow

## 二、主流程
渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。基本流程为：
解析HTML以构建DOM树 -> 解析CSS构建CSSOM -> 将DOM树与CSSOM树合并，构建Render树 -> 布局render树 -> 绘制render树

1. 构建DOM树：当浏览器客户端从服务器那接受到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应。
2. CSS解析：处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)，解析成CSS Rule Tree。
3. 渲染树：根据DOM和CSSOM来构造Render Tree，Render tree不等于DOM Tree,因为像Header或display:none的东西没有必要放在渲染树中。
4. 布局：render layout。
5. 绘制：将渲染树的各个节点绘制到页面上。

注意：`上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。  
以上五个步骤并不一定一次性完成，当DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。`

## 三、浏览器渲染网页的具体流程

### 3.1 构建DOM树
当浏览器客户端从服务器那接受到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应。需要注意记下几点：

1. DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。
2. display:none 的元素也会在DOM树中。
3. 注释也会在DOM树中
4. script标签会在DOM树中

### 3.2 CSS解析
浏览器会解析CSS文件并生成CSS规则树，在过程中，每个CSS文件都会被分析成StyleSheet对象，每个对象都包括CSS规则，CSS规则对象包括对应的选择器和声明对象以及其他对象。
在这个过程需要注意的是：

- CSS解析可以与DOM解析同进行。
- CSS解析与script的执行互斥 。
- 在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥。

### 3.3 渲染树（Rendr tree construction）
通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，让后对每个可见节点找到适配的CSS样式规则并应用。具体的规则有以下几点需要注意：

- Render Tree和DOM Tree不完全对应。
- display: none的元素不在Render Tree中
- visibility: hidden的元素在Render Tree中

### 3.4 布局(layout of the render tree)
布局阶段会从渲染树的更节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：

- float元素，absoulte元素，fixed元素会发生位置偏移。
- 我们常说的脱离文档流，其实就是脱离Render Tree。

### 3.5 绘制（Painting the render tree）
在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。


## 四、阻塞渲染
前面我们有提到这方面的问题，说到资源的阻塞我们清楚的是，现代浏览器总是并行加载自语言。例如当HTML解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍然会辨识该脚本后面的资源，并进行预加载。且由于以下两点。浏览器会延迟 JavaScript 的执行和 DOM 构建：

- CSS 被默认被视为阻塞渲染的资源，因此浏览器将在 CSSOM 构建完毕前不会渲染任何已处理的内容。
- JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性，因此CSS解析与script的执行互斥。

正是由于以上这些原因，script标签的位置很重要我们在实际开发中应该尽量坚持以下两个原则：

- 在引入顺序上，CSS 资源先于 JavaScript 资源。
- JavaScript 应尽量少的去影响 DOM 的构建。


## 五、回流和重绘（reflow和repaint）
我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念:

- reflow（回流）：当浏览器发现某个部分发生了变化从而影响了布局，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫 reflow。 常见的reflow是一些会影响页面布局的操作，诸如Tab，隐藏等。reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。reflow几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会reflow哪一部分的代码，因为他们会相互影响。
- repaint（重绘）： repaint则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。
需要注意的是，display:none 会触发 reflow，而visibility: hidden属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，这在我们上面有提到过。所以 visibility:hidden 只会触发 repaint，因为没有发生位置变化。

我们不能避免reflow，但还是能通过一些操作来减少回流：

- 用transform做形变和位移.
- 通过绝对位移来脱离当前层叠上下文，形成新的Render Layer。

另外有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。


## 六、优化渲染效率建议
结合上文和我看到的一些文章，有以下几点可以优化渲染效率

- 合法地去书写 HTML 和 CSS ，且不要忘了文档编码类型。
- 样式文件应当在 head 标签中，而脚本文件在 body 结束前，这样可以防止阻塞的方式。
- 简化并优化CSS选择器，尽量将嵌套层减少到最小。
- 尽量减少在 JavaScript 中进行DOM操作。
- 修改元素样式时，更改其class属性是性能最高的方法。
- 尽量用 transform 来做形变和位移
